//++
// CommandLine.hpp -> CCommandLine (siple argc/argv parser) class
//
//       COPYRIGHT (C) 2017 BY THE LIVING COMPUTER MUSEUM, SEATTLE WA.
//
// LICENSE:
//    This file is part of the UPE LIBRARY project.  UPELIB is free software;
// you may redistribute it and/or modify it under the terms of the GNU Affero
// General Public License as published by the Free Software Foundation, either
// version 3 of the License, or (at your option) any later version.
//
//    UPELIB is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
// more details.  You should have received a copy of the GNU Affero General
// Public License along with MBS.  If not, see http://www.gnu.org/licenses/.
//
// REVISION HISTORY:
// 24-OCT-15  RLA   New file.
//  1-JUN-17  RLA   Linux port.
//--
#pragma once
#include <string>               // C++ std::string class, et al ...
#include <unordered_map>        // C++ std::unordered_map template
#include <vector>               // C++ std::vector template
using std::string;              // ...
using std::iterator;            // ...
using std::vector;              // ...
using std::unordered_map;       // ...


class CCommandLine {
  //++
  //   This class is a simple, getopt() style, command line parser.  There's a
  // complete description of the syntax and options in the .cpp file.
  //
  //   Note that nearly every method here, with the exception of Parse(), is
  // const.  That's consistent with the design philosophy - you parse the 
  // command line, and then ask questions about the results.
  //--

  // Types, parameters and constants ...
private:
  // Option types returned by GetOptionType() ...
  enum _OPTION_TYPE {
    ILLEGAL,         // this option isn't listed in the ValidOptions
    NO_VALUE,        // this option is valid and does NOT take an argument
    VALUE_REQUIRED,  //   "    "     "   "    "  requires an argument
    VALUE_OPTIONAL   //   "    "     "   "    "  optionally allows an argument
  };
  typedef enum _OPTION_TYPE OPTION_TYPE;

  // Constructor and destructor ...
public:
  CCommandLine (const char *pszValidOptions,
                uint32_t nMinArgs = 0, uint32_t nMaxArgs = UINT32_MAX,
                bool fCaseSensitive = true, const char *pszOptionPrefix = "-/");
  virtual ~CCommandLine() {};
private:
  // Disallow copy and assignment operations with CCommandLine objects ...
  CCommandLine (const CCommandLine&) = delete;
  CCommandLine& operator= (const CCommandLine&) = delete;

  //   The argument list is a simple std::vector of strings, and the option
  // list is a std::unordered_map of option names (a single character) and
  // values (also strings).  Note that we only expose const_iterators for
  // both - these lists are generated by Parse() and can't be modified
  // otherwise.
public:
  typedef unordered_map<char, string> OPTION_LIST;
  typedef vector<string> ARGUMENT_LIST;
  typedef OPTION_LIST::const_iterator option_iterator;
  typedef ARGUMENT_LIST::const_iterator argument_iterator;
  option_iterator   options_begin()   const {return m_OptionList.begin();}
  option_iterator   options_end()     const {return m_OptionList.end();}
  argument_iterator arguments_begin() const {return m_ArgumentList.begin();}
  argument_iterator arguments_end()   const {return m_ArgumentList.end();}

  // Properties ...
public:
  // Return the number of arguments or options found ...
  size_t GetArgumentCount() const {return m_ArgumentList.size();}
  size_t GetOptionCount()   const {return m_OptionList.size();}
  // Test whether a particular option is present on the command line ...
  bool IsOptionPresent(char ch) const
    {return m_OptionList.find(FixCase(ch)) != m_OptionList.end();}
  // Return an argument or option value, if any ...
  string GetArgument (uint32_t n) const;
  string GetOptionValue (char ch) const;
  string operator[] (uint32_t i) const {return GetArgument(i);}
  string operator[] (char ch)    const {return GetOptionValue(ch);}

  // Public methods ...
public:
  // Clear the argument or option list ...
  void ClearArguments() {m_ArgumentList.clear();}
  void ClearOptions()   {m_OptionList.clear();}
  // Add an option or argument to their respective lists ...
  void AddArgument (string str)           {m_ArgumentList.push_back(str);}
  void AddOption (char ch, string str="") {m_OptionList.insert({ch, str});}
  // Remove an argument or option ...
  void RemoveOption  (char ch)    {m_OptionList.erase(ch);}
  void RemoveArgument(uint32_t n) {m_ArgumentList.erase(m_ArgumentList.begin()+n);}
  // Parse a command line ...
  bool Parse (const char *pszProgram, int argc, const char * const argv[]);
  // (Re) Build a command line corresponding to these options and arguments...
  string BuildCommand() const;

  // Local methods ...
protected:
  // Force a character to lower case IF m_fCaseSensitive is NOT set ...
  char FixCase(char ch) const {return m_fCaseSensitive ? ch : tolower(ch);}
  // Search m_sOptionPrefix for a particular character ...
  bool IsOptionPrefix(char ch) const
    {return m_sOptionPrefix.find(ch) != string::npos;}
  // Search m_sValidOptions for the option and return its type ...
  OPTION_TYPE GetOptionType (char ch) const;
  // Parse an option name or value string ...
  bool ParseValue (const char *pszProgram, const char *pszArg, string &sValue);
  bool ParseOption (const char *pszProgram, int &narg, int argc, const char * const argv[]);

  // Local members ...
protected:
  const string   m_sValidOptions;   // mask of legal option letters and arguments
  const uint32_t m_nMaxArguments;   // maximum number of arguments allowed
  const uint32_t m_nMinArguments;   // minimum   "     "   "   "      "
  const string   m_sOptionPrefix;   // prefix characters (e.g. "-/") for options
  const bool     m_fCaseSensitive;  // TRUE if option names are case sensitive
  OPTION_LIST    m_OptionList;      // unordered map of options and vvalues
  ARGUMENT_LIST  m_ArgumentList;    // vector of arguments
};
